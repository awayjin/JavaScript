<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script type="module">
  import Graph from './01-graph-hand.js'
  import Stack from '../03-stack/01-stack.js'

  let graph = new Graph()

  let vertexes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
  // 添加所有的顶点
  vertexes.map(item => graph.addVertex(item))

  // 给 A 添加3条边 B C D
  graph.addEdge('A', 'B')
  graph.addEdge('A', 'C')
  graph.addEdge('A', 'D')

  graph.addEdge('B', 'E')
  graph.addEdge('B', 'F')

  graph.addEdge('C', 'D')
  graph.addEdge('C', 'G')

  graph.addEdge('D', 'G')
  graph.addEdge('D', 'H')

  graph.addEdge('E', 'I')


  console.log('graph.toString()::', graph.toString())

  // bfs
  function printNode (vertex) {
    console.log(vertex)
  }

  graph.bfs(vertexes[0], printNode)

  // 改进版本-BFS
  let shortestPathA = graph.BFS(vertexes[0])
  console.log(Array(20).join('-'), '改进版本-BFS:')
  console.log(shortestPathA)

  console.log(Array(20).join('-'), '追溯路径:', Array(20).join('-'))
  // 通过前溯点数组，构建从 A 点到其他顶点的路径
  // 探索指定顶点的所有路径
  let fromVertex = vertexes[0]
  for (let i = 1; i < vertexes.length; i++) {
    let toVertex = vertexes[i]
    let path = new Stack()

    for (let v = toVertex;
         v !== fromVertex;
         v = shortestPathA.predecessors[v]) {
      path.push(v)
    }

    path.push(fromVertex)
    let s = path.pop()
    
    while (!path.isEmpty()) {
      s += ' - ' + path.pop()
    }

    console.log(s)

  }


  console.log(Array(20).join('-'), '--深度优先搜索--', Array(20).join('-'));
  // 深度优先搜索
  graph.dfs(printNode)

  console.log(Array(20).join('-'), '--改进版DFS-深度优先搜索--', Array(20).join('-'));
  console.log(graph.DFS())


  console.log('********* topological sort - DFS ***********');

  //var result = graph.DFS();
  //console.log(result.discovery);
  //console.log(result.finished);
  //console.log(result.predecessors);


  graph = new Graph()
  let myVertices = ['A','B','C','D','E','F'];
  for (let i=0; i<myVertices.length; i++){
    graph.addVertex(myVertices[i]);
  }
  graph.addEdge('A', 'C');
  graph.addEdge('A', 'D');
  graph.addEdge('B', 'D');
  graph.addEdge('B', 'E');
  graph.addEdge('C', 'F');
  graph.addEdge('F', 'E');


  var result = graph.DFS();
  console.log(result)
  // console.log(result.discovery);
  // console.log(result.finished);
  // console.log(result.predecessors);

  let fTimes = result.finished;
  let s = '';
  for (let count=0; count<myVertices.length; count++){
    let max = 0;
    let maxName = null;
    for (let i=0; i<myVertices.length; i++){
      if (fTimes[myVertices[i]] > max){
        max = fTimes[myVertices[i]];
        maxName = myVertices[i];
      }
    }
    s += ' - ' + maxName;
    delete fTimes[maxName];
  }
  console.log(s);
</script>


<script>

</script>
</body>
</html>