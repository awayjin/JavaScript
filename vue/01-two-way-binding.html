<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0">
  <title>双向数据绑定</title>
</head>
<body>
<pre>
  Record JavaScript CPU Profile 用于分析网页上的JavaScript函数在执行过程中的CPU消耗信息。
  Take Heap Snapshot 创建堆快照用来显示网页上的JS对象和相关的DOM节点的内存分布情况。
  Record Allocation Timeline 从整个Heap角度记录内存的分配信息，利用这个可以实现隔离内存泄漏问题。
  Record Allocation Profile 从JS函数角度记录内存的分配信息。
</pre>
<a href="https://segmentfault.com/a/1190000014274840" target="_blank">
  MVVM-VUE 双向数据绑定实现
</a>

<pre>
  <img src="flow-chart.png" alt="">
  <a href="https://www.cnblogs.com/onepixel/p/6034307.html">MVVM小细节</a>
  MVC
路由至控制器内,需要在控制器自己处理model(data), 然后进行重新渲染生成view(UI)
MVVM
数据驱动式，一旦model有变化, 其view(UI)就会改变.

  new MVVM() -> Observer(数据监听器,劫持监听所有属性) -> Dep(消息订阅器, 收集订阅者) -> Watcher(订阅者，连接Observer和Compile)
  new MVVM() -> Compile(解析指令)

  > Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，
    内部采用Object.defineProperty的getter和setter来实现。

  > Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，
    根据指令模板替换数据，以及绑定相应的更新函数。

  > Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，
    能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。

  > Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），
    数据变动触发 notify 函数，再调用订阅者的 update 方法。
</pre>

<div id="app">
  <h2>  MVVM-VUE 双向数据绑定实现 </h2>
  <form action="">
    <input type="text" v-model="number">
    <button type="button" v-click="increment">btn</button>
  </form>
  <h3 v-bind="number"></h3>
  <h3 v-bind="number"></h3>
</div>
<script>
  // two-way
  window.addEventListener('load', function () {
    console.profile('调优')
    var app = new MyVue({
      el: '#app',
      data: {
        number: 0,
//        dd: null
      },
      methods: {
        increment: function () {
          this.number++
        }
      }
    })
    console.profileEnd('调优')
  }, false)

  var MyVue = function (options) {
    this._init(options)
  }
  MyVue.prototype = {
    // init
    _init: function (options) {
      this.$options = options
      this.$el = document.querySelector(options.el)
      this.$data = options.data
      this.$methods = options.methods

      //_binding保存着model与view的映射关系，也就是Watcher的实例。
      // 当model改变时，我们会触发其中的指令类更新，保证view也能实时更新
      this._binding = {}

      this._obverse(this.$data)
      this._compile(this.$el)

    },
    // 实现_obverse函数，对data进行处理，重写data的set和get函数
    _obverse: function (obj) {
      // 遍历data对象
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          var value
          value = obj[key]
          // 如果值还是对象，继续递归处理
//          if (typeof value === 'object') {
          if (value instanceof Object) {
            console.log(22)
            this._obverse(value)
          }

          // 按照前面的数据，_binding = { number: _directives: [] }
          this._binding[key] = {
            _directives: []
          }

          var binding = this._binding[key]

          // 关键-key
          Object.defineProperty(this.$data, key, {
            enumerable: true, // [ɪ'nju:mərəbəl]可枚举
            configurable: true,
            // 当使用了getter或setter方法，不允许使用writable和value这两个属性
            get: function () {
              console.log(`获取:${value}`)
              return value
            },
            set: function (newVal) {
              console.log(`更新${value}`)
              if (value !== newVal) {
                value = newVal
                console.table(binding._directives)
                binding._directives.forEach(function (item) {
                  item.update()
                })
              }
            }
          })
        }
      }
//      console.log(this._binding)
    },
    // 将view与model进行绑定
    _compile: function (root) {
      var _this = this
      var nodes = root.children
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i]
        // 对所有元素进行遍历，并进行处理
        if (node.children.length) {
          this._compile(node)
        }

        // v-click
        // 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++
        if (node.hasAttribute('v-click')) {
//          node.onclick = (function () {
//            // q1?
//            var attrVal = nodes[i].getAttribute('v-click')
//            // bind是使data的作用域与method函数的作用域保持一致
//            return _this.$methods[attrVal].bind(_this.$data)
//          })()
          node.addEventListener('click', (function (key) {
            var attrVal = node.getAttribute('v-click')
            // bind是使data的作用域与method函数的作用域保持一致
            // return _this.$methods[attrVal].bind(_this.$data)
            return _this.$methods[attrVal].bind(_this.$data)
          })(i))
        }

        // v-model
        if (node.hasAttribute('v-model') && (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA')) {
          node.addEventListener('input', (function (key) {
            var attrVal = node.getAttribute('v-model')
            //_this._binding['number']._directives = [一个Watcher实例]
            // 其中Watcher.prototype.update = function () {
            //    node['vaule'] = _this.$data['number'];  这就将node的值保持与number一致
            // }
            _this._binding[attrVal]._directives.push(new Watcher(
              'input',
              node,
              _this,
              attrVal,
              'value'
            ))

            return function () {
              // 使number 的值与 node的value保持一致，已经实现了双向绑定
              _this.$data[attrVal] = nodes[key].value
            }
          })(i))
        }

        // v-bind
        // 如果有v-bind属性，我们只要使node的值及时更新为data中number的值即可
        if (node.hasAttribute('v-bind')) {
          var attrVal = node.getAttribute('v-bind')
          _this._binding[attrVal]._directives.push(new Watcher(
            'text',
            node,
            _this,
            attrVal,
            'innerHTML'
          ))
        }

      }
    }
  }

  // 写一个指令类Watcher，用来绑定更新函数，实现对DOM元素的更新
  function Watcher(name, el, vm, exp, attr) {
    this.name = name // 指令名称，例如文本节点，该值设为"text"
    this.el = el // 指令对应的DOM元素
    this.vm = vm // 指令所属MyVue实例
    this.exp = exp // 指令对应的值，本例如"number"
    this.attr = attr // 绑定的属性值，本例为"innerHTML"

    this.update()
  }
  Watcher.prototype.update = function () {
    // 比如 H3.innerHTML = this.data.number;
    // 当number改变时，会触发这个update函数，保证对应的DOM内容进行了更新
    this.el[this.attr] = this.vm.$data[this.exp]
  }

</script>


<div id="two-way">
  <h2>简洁版双向绑定</h2>
  <form>
    <input type="text" id="aa" v-model="number">
    <button type="button" v-click="increment">增加</button>
  </form>
  <h3 v-bind="number"></h3>
</div>

<span type="text" id="bb" v-model="number"></span>


<script>
  // 简单基础实现
  var obj = {};
  Object.defineProperty(obj,'hello',{
    get: function () {
      console.log(obj.hello)
      return obj.hello
    },
    set:function(val){
      document.getElementById('bb').innerHTML = val;
      document.getElementById('aa').value = val;
    }
  });
  document.getElementById('aa').onkeyup = function(e){
    obj.hello = e.target.value;
  };
  obj.hello = "default value";
</script>

<!--

<script>


  function MyVue (options) {
    this._init(options)
  }
  MyVue.prototype = {
    // init
    _init: function (options) {
      this.$options = options
      this.$el = document.querySelector(options.el)
      this.$data = options.data
      this.$methods = options.methods

      this._binding = {}
      this._obverse(this.$data)
      this._compile(this.$el)
    },
    // obverse
    _obverse: function (obj) {
      var value
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          this._binding[key] = {
            _directives: []
          }

          value = obj[key]
          if (typeof value === 'object') { // 如果值还是对象，则遍历处理
            this._obverse(value)
          }

          var binding = this._binding[key]

          // key关键
          Object.defineProperty(this.$data, key, {
            enumerable: true,
            configurable: true,
            get: function () {
              console.log(`获取${value}`)
              return value
            },
            set: function (newVal) {
              if (value !== newVal) {
                value = newVal
                binding._directives.forEach(function (item) {
                  item.update()
                })
              }
              console.log(`更新${newVal}`)
            }
          })
        }
      }
    },
    // compile
    _compile: function (root) {
      var _this = this
      var nodes = root.children
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i]
        if (node.children.length) {
          this._compile(node)
        }

        // v-click
        if (node.hasAttribute('v-click')) {
          node.onclick = (function () {
            var attrVal = nodes[i].getAttribute('v-click')
            return _this.$methods[attrVal].bind(_this.$data)
          })()
        }

        // input and textarea
        if (node.hasAttribute('v-model') && (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) {
          node.addEventListener('input', (function (key) {
            var attrVal = node.getAttribute('v-model')
            _this._binding[attrVal]._directives.push(new Watcher(
              'input',
              node,
              _this,
              attrVal,
              'value'
            ))

            return function () {
              _this.$data[attrVal] = nodes[key].value
            }
          })(i))
        }

        // v-bind
        if (node.hasAttribute('v-bind')) {
          var attrVal = node.getAttribute('v-bind')
          _this._binding[attrVal]._directives.push(new Watcher(
            'text',
            node,
            _this,
            attrVal,
            'innerHTML'
          ))
        }

      }
    }
  }

  // 指令类Watcher
  function Watcher (name, el, vm, exp, attr) {
    this.name = name
    this.el = el
    this.vm = vm
    this.exp = exp
    this.attr = attr

    this.update()
  }

  Watcher.prototype = {
    update: function () {
      this.el[this.attr] = this.vm.$data[this.exp]
    }
  }

  window.onload = function () {
    var app = new MyVue({
      el: '#app',
      data: {
        number: 0
      },
      methods: {
        increment: function () {
          this.number++
        }
      }
    })
  }
</script>
-->

</body>
</html>