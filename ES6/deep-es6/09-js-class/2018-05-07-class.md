---
layout: post
title:  "js中的类"
date:   2018年05月07日 15:46:32
categories: JavaScript
excerpt: ES6类、ES5中仿类结构
---

* content
{:toc}

---

# js中的类
## 1.ES5中仿类结构
>创建一个构造器，然后将方法指派到该构造器的原型上。
>这种方式通常被称为创建一个自定义类型
```javascript
function PersonType(name)	{
  this.name = name;
}
PersonType.prototype.sayName = function()	{
  console.log(this.name)
}
```

## 2.ES6类的声明
> class开始，其后是类的名称.像对象字面量，无需逗号.
```javascript
class PersonClass {
  // 等价于	PersonType	构造器
  constructor(name)	{
    this.name = name
  }
  // 等价于	PersonType.prototype.sayName
  sayName()	{
    console.log(this.name)
  }
}
let	person	=	new	PersonClass("Nicholas")
person.sayName()			// 输出"Nicholas"
console.log(typeof PersonClass) // "function"
```
>PersonClass 声明实际上创建了一个拥有 constructor 方法及其行为的函数.所以typeof PersonClass得到 'function'

## 3.类与自定义类型的区别
- **类声明**不会被提升
- 运行在**严格模式**下, use strict
- 类所有方法**不可枚举**.自定义类型必须用Object.defineProperty才不可枚举
- 所有**类方法**内部都没有 [[Constrouctor]],使用new 调用会出错
- 调用**类构造器**必须用new, new ClassName
- 试图在类的方法内部**重写**类名，会抛出错误, 因为是const
```javascript
   // new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。
  // 在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。
  // 在普通的函数调用中，new.target 的值是undefined。
  // 等价于 class PersonClass
  let PersonType = (function () {
    'use strict'
    const PersonType = function (name) {
      // 确认函数被调用时使用了 new
      if (typeof new.target === 'undefined') {
        throw new Error('Constructor must be called with new.')
      }
      console.log(new.target)
      this.name = name
    }

    Object.defineProperty(PersonType.prototype, 'sayName', {
      value: function () {
        console.log(new.target)
        // 确认方法被调用时没有使用 new
        if (typeof new.target !== 'undefined') {
          throw new Error('Method cannot be called with new.')
        }
        console.log(this.name)
      },
      enumerable: false,
      // 是否可以被重写, 默认为false
      writable: false,
      // 是否可以删除目标属性或是否可以再次修改属性的特性，默认false
      configurable: true
    })

    return PersonType
  })()
```


### 3.1 不变的类名
只有在类的内部才是const声明，在外部重写没问题。因为内部是const,外部是let声明

## 4.类表达式与声明Class Expressions
> 类与函数两种形式： 声明与表达式。 声明： class identifier, function identifier标识符(函数名或类名)
- 相较于函数声明与函数表达式。类声明与类表达式仅语法差异，都不会被提升。
```javascript
let PersonClass = class { }
```
- 具名类表达式(named class expression), PersonClass2只在类定义内部存在
```javascript
let PersonClass = class PersonClass2 {
  
 }
```
### 4.1 作为一等公民的类 first-class citizen
> 一等公民：能被当作值来使用。意味着能当作参数传给函数，能作为函数返回值，当变量赋值

- 当作参数传给函数
```javascript
function createObject (classDef) {
    return new classDef
  }
  var obj = createObject(class {
    sayHi () {
      console.log('hi')
    }
  })
  obj.sayHi()
```
- 类表达式-立即调用类构造器，以创建单例.
单例模式，是一种常用的软件设计模式。单例对象的类必须保证只有一个实例存在。
```javascript
    // 类语法创建单例
    let person = new class {
      constructor (name) {
        this.name = name
      }
      sayName () {
        console.log(this.name);
      }
    }('away')
    person.sayName()
```

## 5.类上创建访问器属性(Accessor Properties)
```javascript
// 访问器属性
  class CustomHTMLElement {
    constructor (element) {
      this.element = element
    }

    sayHi () {
      console.log(this.element)
    }

    get html () {
      return this.element.innerHTML
    }

    set html (value) {
      this.element.innerHTML = value + '--aa'
    }
  }

  // getOwnPropertyDescriptor 返回某个对象属性的描述对象（ descriptor ）
  var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, 'html')
  console.log('get' in descriptor)
  console.log('set' in descriptor)
  console.log(descriptor.enumerable)
```

```javascript
// direct equivalent to previous example
let CustomHTMLElement = (function() {

    "use strict";

    const CustomHTMLElement = function(element) {

        // make sure the function was called with new
        if (typeof new.target === "undefined") {
            throw new Error("Constructor must be called with new.");
        }

        this.element = element;
    }

    Object.defineProperty(CustomHTMLElement.prototype, "html", {
        enumerable: false,
        configurable: true,
        get: function() {
            return this.element.innerHTML;
        },
        set: function(value) {
            this.element.innerHTML = value;
        }
    });

    return CustomHTMLElement;
}());
```

## 6.需计算的成员属性Computed Member Names
> 无须使用标识符,方括号来包裹一个表达式
```javascript
// 需计算的成员名
  let methodName = 'sayName'
  class PersonClass {
    constructor (name) {
      this.name = name
    }

    [methodName] () {
      console.log(this.name)
    }
  }

  let me = new PersonClass('Away')
  me.sayName()

  var obj = {
    [methodName]: '222'
  }
```

## 7.生成器方法
> 在方法名称前加一个星号*
```javascript
// 类的生成器方法
  class MyClass {
    *createIterator () {
      yield 31
      yield 2
      yield 9
    }
  }

  let instance = new MyClass()
  let iterator = instance.createIterator()
  iterator.next()
  iterator.next()
```