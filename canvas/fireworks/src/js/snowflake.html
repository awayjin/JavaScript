<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0">
  <title>Title</title>
  <style>
    canvas { position: absolute;; left: 0; top: 0}
    *{
      margin: 0;
      padding: 0;
    }
    html,body{
      width: 100%;
      height: 100%;
    }
    body{
      position: relative;
      margin: 0 auto;
    }
  </style>
</head>
<body>

<canvas id="bg" style="background-color: #bfbfbf"></canvas>
<canvas id="snow"></canvas>

<script>
  const width = 360
  const height = 600
  const util = {
    random (min = 0, max) {
      // let random = Math.random()
      return min + (max - min) * Math.random()
    },
    extend (origin, ...arg) {
      arg.forEach(item => {
        for (let key in item) {
          origin[key] = item[key]
        }
      })
      return origin
    }
  }

  class Particle {
    constructor ({x, y, minSize = 15, maxSize = 7.5, size, opacity = 1} = {}) {
      this.size = size ? size : util.random(minSize, maxSize) // eslint-disable-line
      this.x = x ? x : util.random(0, (width - this.size)) // eslint-disable-line
      this.y = y === false ? y : -this.size
      this.opacity = opacity
    }

    outofBounds () {
      if (this.x >= -this.size &&
        this.x <= width &&
        this.y <= height &&
        this.y >= -this.size) {
        return false
      } else {
        return true
      }
    }
  }

  class Snowflake extends Particle {
    constructor ({x, y, minSize = 5, maxSize = 7.5, size = 10, speed = 0.5} = {}) {
      super({x, y, minSize, maxSize, size})
      this.speed = speed * (1 + Math.random())
      this.direction = Math.random() > 0.5 ? 0.5 : -0.5
      this.size = size
    }

    render (context) {
      this.fall()
      if (this.outofBounds()) return false
      this.opacity = 0
      this.g = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size)
      this.g.addColorStop(0, `hsla(255, 255%, 255%, ${this.opacity})`)
      this.g.addColorStop(1, 'hsla(255, 255%, 255%, 0)')

      context.beginPath()
      context.fillStyle = this.g
      context.arc(this.x, this.y, this.size, 0, Math.PI * 2, false)
      context.fill()
    }

    fall () {
      this.x += Math.random() * this.direction
      this.y += this.speed
    }
  }

  // new Snowflake()


  class Canvas {
    constructor () {

      this.config = {
        canvases: ['bg', 'snow'],
        width: width,
        height: height,
        snow: {
          x: undefined,
          y: undefined,
          size: undefined,
          minSize: 5,
          maxSize: 10,
          speed: 0.5,
          opacity: 0.8
        }
      }
      this.time = 0 // 动画的时间
      this.fallDots = []
      this.resize(this.config.canvases, width, height)
      this.initProperty()
      this.loop()
    }

    loop () {
      window.requestAnimationFrame(this.loop.bind(this))
      this.time = ++this.time >= 60000 ? 0 : this.time
      this.renderFall()
    }

    renderFall () {
      this.snowCtx.clearRect(0, 0, width, height)
      let snow
      if (this.time % 60 === 0) {
        this.fallDots.push(new Snowflake(this.config.snow))
      }
      for (let i = this.fallDots.length - 1; i >= 0; --i) {
        !this.fallDots[i].render(this.snowCtx) && this.fallDots.splice(i, 1)
      }
    }
    initProperty () {
      let config = this.config
      config.canvases.forEach(canvasId => {
        let el = document.querySelector('#' + canvasId)
        el.width = config.width
        el.height = config.height
        this[canvasId + 'Ctx'] = el.getContext('2d')
      })
      let center = config.width / 2
      let radius = center - 2
      this.snowCtx.arc(center, center, radius, 0, Math.PI * 2, false)
      this.snowCtx.stroke()
    }

    resize (canvas, width = width, height = height) {
      // 用户代理检测
      if (!/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
        const body = document.querySelector('body')
        body.style.width = width + 'px'
        body.style.height = height + 'px'
      }

      // 设置各画布的宽高
      canvas.forEach(canvas => {
        let el = document.querySelector(`#${canvas}`)
        el.width = width
        el.height = height
      })
    }
  }
  new Canvas()
</script>

</body>
</html>